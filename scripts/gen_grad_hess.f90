!
!    This program is a utility-tool for DG-EVB-QMDFF and TREQ
!    It generates the ref.input file for a calculation
!    which includes the geometries, gradients and hessians 
!    for each reference point on the reactionpath
!

program gen_dg_evb
implicit none
integer::n_shep,nat,nat3,maxline
integer iunit,i,j,mincol,maxcol,idum,m,k,l
character(len=100) fname
character(len=80) a80,text
character(len=60)::change
character(len=30)::buffer
character(len=5) adum
character(len=1)::method
character(len=:),allocatable::chari
real(kind=8) energy,test2,e_ref
real(kind=8),dimension(:,:),allocatable::grad
real(kind=8),dimension(:,:),allocatable::h,xyz
real(kind=8),dimension(:),allocatable::g_out,h_out,xyz_out
real(kind=8),dimension(:),allocatable::grad1d,hess1d,hess1d2,xyz1d
integer::gradline  ! number of lines in gradient array
integer::natsum,sum1,sum2,cp2k_read_en,cp2k_read_grad
logical::snforca
logical::extra_ens  ! if the energies were calculated with another level of theory
real(kind=8)::ens_other(10000)  ! the extra energies
integer,allocatable::ens_position(:)  ! the positions of the needed energies
integer::readstat  ! for estimation of the line number
! for CP2K output
real(kind=8),dimension(:,:),allocatable::grads
real(kind=8)::diffstep
real(kind=8)::bohr

write(*,*) "This program generates the grad_hess.dat input file for an DG-EVB-QMDFF or TREQ"
write(*,*) "calculation from orca/Gaussian/CP2K-output. The outputfiles for each point must"
write(*,*) "in Folders named 1,2,3,...,n, where n(<=9) is the number of reference points."
write(*,*) "In each folder in outputfiles run.hess and run.engrad (for orca)" 
write(*,*) "or gauss.chk (for gaussian) or run.out (for CP2K) must be present."
write(*,*) "The absolute value of the energies is noted; the reference-point"
write(*,*) "should therefore be substracted afterwards (maybe?)."
write(*,*) "If the energies were calculated with a different level of theory, the file"
write(*,*) "ref.dat and struc_num.txt with all energies and the numbers are needed."
write(*,*) 
write(*,*) "How many reference-points are used?"
read(*,*) n_shep
write(*,*) "How many atoms are in the system?"
read(*,*) nat
write(*,*) "Did you performed orca, gaussian or CP2K calculations? (O/G/C)"
read(*,*) method
allocate(grad(3,nat))
allocate(grad1d(3*nat))
allocate(xyz1d(3*nat))
allocate(hess1d(((3*nat)*(3*nat+1))/2))
allocate(hess1d2((3*nat)*(3*nat)))
allocate(xyz(3,nat))
allocate(h(3*nat,3*nat))
allocate(g_out(3*nat),xyz_out(3*nat),h_out(3*3*nat*nat))
nat3=3*nat
allocate(grads(2*nat3,nat3))

!
!   iterate through the subdirs and extract gradient/energy/hessian
!

open(unit=15,file="grad_hess.dat",status="unknown")
write(15,'(A)') "# This is an input file for DG-EVB-QMDFF or TREQ, "
write(15,'(A)') "# generated by gen_grad_hess." 
write(15,*)
write(15,'((A),(I2))') "NPOINTS",n_shep
write(15,*)
write(15,'((A),(I3))') "NATOM",nat
write(15,*)

write(*,*)  n_shep
!stop
test2=0.0000020727626d0
bohr=0.52917721092d0
!write(*,'(E15.8)') test2
!
!    if the energies were calculated with a different level of theory!
!

inquire(file="ref.dat", exist=extra_ens)
if (extra_ens) inquire(file="struc_num.txt", exist=extra_ens)
if (extra_ens) then
   write(*,*) "Both the files ref.dat and struc_num.txt are present!"
   write(*,*) "Therefore the energies will be read from ref.dat."
   open(unit=16,file="ref.dat",status="old") 
   i=1 
!
!    read all path energies from ref.dat
! 
   do 
      read(16,*,iostat=readstat) ens_other(i)
      if (readstat .ne. 0) exit
      i=i+1
   end do
   close(16)
!
!    read the positions of the energies in the struc_num.txt file
!
   allocate(ens_position(n_shep))
   open(unit=17,file="struc_num.txt")
   do i=1,n_shep
      read(17,*) ens_position(i)
   end do
   close(17)
end if



do l=1,n_shep
   if (l .lt. 10) then
      allocate(character(len=1)::chari)
      write(chari,"(I1)") l
   else 
      allocate(character(len=2)::chari)
      write(chari,"(I2)") l
   end if
!   write(chari,"(I2)") l
!   write(*,*) "CHARI",chari
!   call system ("pwd")
!   write(*,*) "chari",chari
   CALL chdir(chari)
!   call system("cd  ",l)
!   call system ("pwd")
   write(15,'((A),(I3))') "*POINT",l
   write(*,'((A),(I3),(A))') "*POINT",l,":"
   write(15,*)
!
!  read in the informations 
!  
   if (method .eq. "O") then
!
!  for Orca calculations
!
      open(unit=11,file="run.engrad")

10    read(11,'(a)',end=30)a80
      if(index(a80,'# The current total energy in Eh').ne.0) then
         read(11,'(a)',end=30)a80
         read(11,*) energy
      end if
      if(index(a80,'# The current gradient in Eh/bohr').ne.0)then
         read(11,'(a)',end=30)a80
         do k=1,nat
            do m=1,3
               read(11,*) grad(m,k)
            enddo
         enddo
      endif
      if(index(a80,'# The atomic numbers and current coordinates in Bohr').ne.0)then
         read(11,'(a)',end=30)a80
         do k=1,nat
            read(11,*) text,xyz(1,k),xyz(2,k),xyz(3,k)
         enddo
      endif
      goto 10
30    close(11)

      open(unit=13,file="run.hess")
      m=nat3/6
      if(mod(nat3,6).gt.0)m=m+1

11    read(13,'(a)',end=31)a80
      if(index(a80,'$act_energy').ne.0)snforca=.false.
      if(index(a80,'$hessian').ne.0)then
         read(13,'(a)',end=31)a80
         maxcol = 0
         do k=1,m
            read(13,'(a)')a80
            mincol = maxcol + 1
            maxcol = min(maxcol+5,nat3)
            if(snforca)then
               do i=1,nat3
                  read(13,*)adum,(h(i,j),j=mincol,maxcol)
               enddo
            else
               do i=1,nat3
                  read(13,*)idum,(h(i,j),j=mincol,maxcol)
               enddo
            endif
         enddo
      endif
      goto 11
31    close(13,status='keep')
   else if (method .eq. "G") then
!
!   For Gaussian calculations
!
      call system("formchk gauss.chk gauss.fchk")
      open(unit=11,file="gauss.fchk") 
!
!   Read in the energy
!
12    read(11,'(a)',end=32)a80
      if(index(a80,'Total Energy').ne.0) then
         read(a80,*) buffer,buffer,buffer,energy
      end if
! 
!   Read in cartesian coordinates (1d Array)
!
      maxcol=0
        
      if(index(a80,'Current cartesian coordinates').ne.0)then
!
!   if all lines are full, read one less
!
         if (int(nat3/5)*5 .eq. int(nat3)) then
            gradline=int(nat3/5)
         else
            gradline=int(nat3/5)+1
         end if
         do i=1,gradline
            mincol = maxcol + 1
            maxcol = min(maxcol+5,nat3)
            read(11,*) (xyz1d(j),j=mincol,maxcol)            
         enddo
         do i=1,nat
            do j=1,3
               xyz(j,i)=xyz1d((i-1)*3+j)
            end do
         end do
      end if

! 
!   Read in gradient (1d Array)
!
      if(index(a80,'Cartesian Gradient').ne.0)then
!
!   if all lines are full, read one less
!
         if (int(nat3/5)*5 .eq. int(nat3)) then
            gradline=int(nat3/5)
         else
            gradline=int(nat3/5)+1
         end if

         do i=1,gradline
            mincol = maxcol + 1
            maxcol = min(maxcol+5,nat3)
            
            read(11,*) (grad1d(j),j=mincol,maxcol)
         enddo
         do i=1,nat
            do j=1,3
               grad(j,i)=grad1d((i-1)*3+j)
            end do
         end do 
      end if  
!
!   Read in the hessian (upper triangular matrix)
!
      if(index(a80,'Cartesian Force Constants').ne.0)then
         do i=1,int(((nat3*(nat3+1))/10)+1)
            mincol = maxcol + 1
            maxcol = min(maxcol+5,(nat3*(nat3+1))/2)
            read(11,*) (hess1d(j),j=mincol,maxcol)

         enddo
         do i=1,nat3
            do j=1,nat3
               if (j .le. i) then
                  natsum=((i-1)*i)/2
                  sum1=(i-1)*nat3+j
                  sum2=(j-1)*nat3+i
                  hess1d2(sum1)=hess1d(natsum+j)
                  hess1d2(sum2)=hess1d2(sum1)
               end if
            end do
         end do
      end if
      
      goto 12
      stop
32    close(11)

   !   write(*,*) grad1d

      do i=1,nat3
         do j=1,nat3
            h(i,j)=hess1d2((i-1)*nat3+j)
         end do
      end do
!
!    for CP2K output: calculate frequencies from gradient output!
!
!    The energies:
!
   else if (method .eq. "C") then
      cp2k_read_en=0
      cp2k_read_grad=0
      open(unit=11,file="run.out")
13    read(11,'(a)',end=33)a80
      if((index(a80,'Total Energy:').ne.0) .and. (cp2k_read_en .eq.0)) then
         read(a80,*) buffer,buffer,buffer,energy
!
!    read only the first energy entry!
!
         cp2k_read_en=1
      end if
!
!    read the gradients
!
      if((index(a80,'ATOM                            X                Y                Z') &
           & .ne. 0) .and. (cp2k_read_grad .eq.0))then
         do k=1,nat
            read(11,*) buffer, buffer, grad(:,k)
         end do
         cp2k_read_grad=1
      endif
!
!     read the geometries
!
      if(index(a80,'MODULE QUICKSTEP:  ATOMIC COORDINATES').ne.0)then
         read(11,'(a)',end=33)a80
         read(11,'(a)',end=33)a80
         read(11,'(a)',end=33)a80
         do k=1,nat
            read(11,*) buffer,buffer,buffer,buffer,xyz(1,k),xyz(2,k),xyz(3,k),buffer,buffer
         enddo
         xyz=xyz/bohr
      endif
!
!     read the hessian:
!
!     define number of 6 column lines
!
      m=nat3/5
      if (mod(nat3,5).gt.0) m=m+1

!
!     TEST1: read in gradients and calculate hessian from them
!
      if (index(a80,' VIB| Vibrational Analysis Info').ne.0) then
         do i=1,2*nat3
!
!    read the header lines of each block
!
            read(11,'(a)') a80
            read(11,'(a)') a80
            read(11,'(a)') a80
!
!    fill the big gradient array with the actual gradient
!
            do k=1,nat
               read(11,*) adum,adum,grads(i,(k-1)*3+1),grads(i,(k-1)*3+2),grads(i,(k-1)*3+3)
            end do
         end do
      goto 300
      end if

      300 continue
      diffstep=1.0d-2
      do i=1,nat3
         do j=1,nat3
            h(i,j)=-(grads(i,j)-grads(i+nat3,j))/(2d0*diffstep)
         end do
      end do

      goto 13
33    close(11)
   else 
      stop "This method doesn´t exist! Choose O, G or C!"
   end if
!
!  write the informations to the esp.fu83-file
!
!  if the energies were calculated with another level of theory, take them
!
   if (extra_ens) then
      energy=ens_other(ens_position(l))
   end if
   write(15,'((A),(F18.10))') "ENERGY",energy
   write(15,*)
   write(15,'(A)') "GEOMETRY"
   do j=1,nat
      do m=1,3
         xyz_out((j-1)*3+m)=xyz(m,j)
      end do
   end do
   maxline= int(size(xyz_out)/5)
   do j=0,maxline-1
      write(15,'((E16.7),(E16.7),(E16.7),(E16.7),(E16.7))') &
          &xyz_out(j*5+1),xyz_out(j*5+2),xyz_out(j*5+3),xyz_out(j*5+4),xyz_out(j*5+5)
   end do     
   if (size(xyz_out)-maxline*5 .eq.4) then
       write(15,'((E16.7),(E16.7),(E16.7),(E16.7))') &
          &xyz_out(j*5+1),xyz_out(j*5+2),xyz_out(j*5+3),xyz_out(j*5+4)
   else if (size(xyz_out)-maxline*5 .eq.3) then
       write(15,'((E16.7),(E16.7),(E16.7))') &
          &xyz_out(j*5+1),xyz_out(j*5+2),xyz_out(j*5+3)
   else if (size(xyz_out)-maxline*5 .eq.2) then
       write(15,'((E16.7),(E16.7))') &
          &xyz_out(j*5+1),xyz_out(j*5+2)
   else if (size(xyz_out)-maxline*5 .eq.1) then
       write(15,'((E16.7))') &
          &xyz_out(j*5+1)
   end if
   write(15,'(A)') "END"
   write(15,*)
   write(15,'(A)') "GRADIENT"
   do j=1,nat
      do m=1,3
         g_out((j-1)*3+m)=grad(m,j)
      end do
   end do
   do j=0,maxline-1
      write(15,'((E16.7),(E16.7),(E16.7),(E16.7),(E16.7))') &
          &g_out(j*5+1),g_out(j*5+2),g_out(j*5+3),g_out(j*5+4),g_out(j*5+5)
   end do
   if (size(xyz_out)-maxline*5 .eq.4) then 
      write(15,'((E16.7),(E16.7),(E16.7),(E16.7))') &
          &g_out(j*5+1),g_out(j*5+2),g_out(j*5+3),g_out(j*5+4)
   else if (size(xyz_out)-maxline*5 .eq.3) then
      write(15,'((E16.7),(E16.7),(E16.7))') &
          &g_out(j*5+1),g_out(j*5+2),g_out(j*5+3)
   else if (size(xyz_out)-maxline*5 .eq.2) then
      write(15,'((E16.7),(E16.7))') &
          &g_out(j*5+1),g_out(j*5+2)
   else if (size(xyz_out)-maxline*5 .eq.1) then
      write(15,'((E16.7))') &
          &g_out(j*5+1)
   end if

   write(15,'(A)') "END" 
   write(15,*)
   write(15,'(A)') "HESSIAN"
   do j=1,3*nat
      do m=1,3*nat
         h_out((j-1)*3*nat+m)=h(m,j)
      end do
   end do
   maxline= int(size(h_out)/5)
   do j=0,maxline-1
      write(15,'((E16.7),(E16.7),(E16.7),(E16.7),(E16.7))') &
          &h_out(j*5+1),h_out(j*5+2),h_out(j*5+3),h_out(j*5+4),h_out(j*5+5)
   end do
   if (size(h_out)-maxline*5 .eq.4) then
      write(15,'((E16.7),(E16.7),(E16.7),(E16.7))') &
          &h_out(j*5+1),h_out(j*5+2),h_out(j*5+3),h_out(j*5+4)
   else if (size(h_out)-maxline*5 .eq.3) then
      write(15,'((E16.7),(E16.7),(E16.7))') &
          &h_out(j*5+1),h_out(j*5+2),h_out(j*5+3)
   else if (size(h_out)-maxline*5 .eq.2) then
      write(15,'((E16.7),(E16.7))') &
          &h_out(j*5+1),h_out(j*5+2)
   else if (size(h_out)-maxline*5 .eq.1) then
      write(15,'((E16.7))') &
          &h_out(j*5+1)
   end if

   write(15,'(A)') "END"
   write(15,*)

   CALL chdir("..")
   deallocate(chari)
end do
close(15)
write(*,*) "Exiting normally..."
end program gen_dg_evb
