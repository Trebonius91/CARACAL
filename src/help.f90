!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!   EVB-QMDFF - RPMD molecular dynamics and rate constant calculations on
!               black-box generated potential energy surfaces
!
!   Copyright (c) 2021 by Julien Steffen (steffen@pctc.uni-kiel.de)
!                         Stefan Grimme (grimme@thch.uni-bonn.de) (QMDFF code)
!
!   Permission is hereby granted, free of charge, to any person obtaining a
!   copy of this software and associated documentation files (the "Software"),
!   to deal in the Software without restriction, including without limitation
!   the rights to use, copy, modify, merge, publish, distribute, sublicense,
!   and/or sell copies of the Software, and to permit persons to whom the
!   Software is furnished to do so, subject to the following conditions:
!
!   The above copyright notice and this permission notice shall be included in
!   all copies or substantial portions of the Software.
!
!   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
!   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
!   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
!   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
!   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
!   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
!   DEALINGS IN THE SOFTWARE.
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!
!     subroutine help: print helping informations about used 
!        programs in the EVB-QMDFF program package: short 
!        introduction, basic calculations and list of all 
!        keywords
!        after this subroutine, the code for help_evb follows
!        which contains all general EVB keywords
!
!     part of EVB
!
subroutine help(progname)
implicit none 
character(len=*)::progname

!
!     Print general overview about program package and its parts
!
write(*,*) "-------------------- EVB-QMDFF HELP --------------------------------"
write(*,*) "--- qmdffgen.x  -----Generating QMDFFs from reference infos --------"
write(*,*) "--- evbopt.x ------- Optimizing EVB coupling terms -----------------"
write(*,*) "--- egrad.x -------- Calculating energies and gradients ------------"
write(*,*) "--- explore.x ------ Pseudo QM package (geoopt, freq,...) ----------"
write(*,*) "--- dynamic.x ------ Run molecular dynamics trajectories -----------"
write(*,*) "--- calc_rate.x ---- Calculating rate constants with (RP)MD --------"
write(*,*) "--- evb_kt_driver.x- Black box k(T) calculations (beta vers.!) -----" 
write(*,*) "--- mult_qmdff.x---- QMDFF solvent box generation ------------------"
write(*,*) "--------------------------------------------------------------------"
!
!     Program QMDFFGEN: general infos and listing of QM reference commands
!
if (trim(progname) .eq. "qmdffgen") then
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "------ PROGRAM QMDFFGEN.X : SHORT OVERVIEW AND HELP --------------"
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "--- PART A: basic usage:------------------------------------------"
   write(*,*) "This program generates QMDFFs from input data! Different quantum"
   write(*,*) "chemistry packages might be used to generate the needed input."
   write(*,*) "The basic usage is:  qmdffgen.x (without parameters)"
   write(*,*) "Currently, one to three QMDFFs can be generated at once (to"
   write(*,*) "be connected with EVB at a later stage!)."
   write(*,*) "After finishing the calculation, a qmdff.key file with relative"
   write(*,*) "energies of the QMDFF minima is generated, this is the starting"
   write(*,*) "point for upfollowing EVB optimizations and other programs."
   write(*,*) "Additionally, for each minimum, [name]_qmdff.log (optimization"
   write(*,*) "information), [name]_molden.out (frequency visualization) are "
   write(*,*) "written."
   write(*,*) "If one QMDFF is generated, the file 'coord_analysis.dat' containg"
   write(*,*) "internal coordinate information is written as well as the file "
   write(*,*) "'coord_def.inp' containing the internal coordinate set."
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "--- PART B: Kinds of input data and its generation:---------------"
   write(*,*) "Currently, reference informations can be generated by orca,"
   write(*,*) "Gaussian, Turbomole, CP2K and EVB-QMDFF (debug) calculations." 
   write(*,*) "The needed keywords for this types of calculations are:"
   write(*,*) "**** orca ****: An opt and freq calculations must be done."
   write(*,*) "Keywords: ! [method,basis] opt freq "
   write(*,*) "           %output \n  Print[ P_Hirshfeld ] 1  \n end"
   write(*,*) "**** Gaussian 09/16 ****: Optimization and frequency calcs must"
   write(*,*) "be done separately! After the standard optimization the freq."
   write(*,*) "calculation has the commands:"
   write(*,*) "p freq [method,basis] pop=(hirshfeld,nboread) density=current"
   write(*,*) "  iop(7/33=1,6/80=1), after structure: $nbo bndidx $end"
   write(*,*) "**** EVB-QMDFF ****: First, an evb_qmdff.x calculation must"
   write(*,*) "be done (optimization and frequency), then, an orca calculation"
   write(*,*) "is followed (single point) to calculate charges and WBOs."
   write(*,*) "**** Turbomole ****: ----"
end if
!
!     Program EVBOPT: general infos and list of all keywords
!
if (trim(progname) .eq. "evbopt") then
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "------ PROGRAM EVBOPT.X : SHORT OVERVIEW AND HELP ----------------"
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "--- PART A: basic usage:------------------------------------------"
   write(*,*) "This program optimizes the EVB coupling term between two or "
   write(*,*) "three single QMDFFs. From this it follows that the program "
   write(*,*) "qmdffgen.x should be executed first. It produces a qmdff.key"
   write(*,*) "file as well as two/three QMDFF files, generically min1.qmdff,"
   write(*,*) "min2.qmdff (and min3.qmdff). To invoke a calculation of this"
   write(*,*) "program, type 'evbopt.x qmdff.key' in order to start the EVB"
   write(*,*) "optimization."
   write(*,*) "This means that the pre generated qmdff.key file should be "
   write(*,*) "used here; it contains the energy shifts of the QMDFFs."
   write(*,*) "For all availiable coupling methods at least the structures"
   write(*,*) "and energies of a reaction path connecting both QMDFF minima"
   write(*,*) "are needed at least, in some cases additional (gradient/hessian)"
   write(*,*) "information about single points along the path is needed."
   write(*,*) "This calculation can be done in parallel. To invoke this,"
   write(*,*) "type 'mpirun -np [nprocs] [absolute path]/evbopt.x qmdff.key'"
   write(*,*) "During the calculation, a logfile 'evbopt.log' will be written."
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "--- PART B: Avail. coupling terms and needed infos:---------------"
   write(*,*) "**** dE-coupling ****: This is the simplest possible EVB-coupling"
   write(*,*) "term. The coupling depends only on the energy difference between"
   write(*,*) "both QMDFFs. "
   write(*,*) "Input: [QMDFF1], [QMDFF2], [path energies], [path xyz-strucs]"
   write(*,*) "If no other keyword is given, the simplest 1g-coupling is assumed."
   write(*,*) "**** dQ-coupling ****: (Mostly obsolet): Takes the geometric"
   write(*,*) "distance to the TS as criterion for coupling strength. Uses same"
   write(*,*) "coupling functions like dE-EVB, with dQ instead of dE. A file "
   write(*,*) "with the xyz-structure of the TS is needed in addition."
   write(*,*) "Activate it with keyword 'EVB_DQ [name of TS file]'."
   write(*,*) "**** DG-EVB coupling ****: The famous Distributed Gaussian term"
   write(*,*) "by Sonnenberg and Schlegel, varied to allow automatic paramet-"
   write(*,*) "rization and optimization"
   write(*,*) "In addition to structures/energies of the minimum energy path,"
   write(*,*) "informations on N additional DG-EVB points are needed as input"
   write(*,*) "reference to optimize the coupling term."
   write(*,*) "Activate it with keyword 'DG_EVB [number of DG-EVB points]'."
   write(*,*) "Input: [QMDFF1], [QMDFF2], [path energies], [path xyz-strucs],"
   write(*,*) "  [DG-EVB points (ref.input)], [opt: coord_def.inp (coords)]."
   write(*,*) "**** RP-EVB coupling ****: Juliens Reaction Path EVB coupling."
   write(*,*) "This term needs no optimization, look into e.g. egrad."
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "--- PART C: List of all available keywords:-----------------------"
   write(*,*) "These keywords can be written into the qmdff.key input file:"
   write(*,*) " * PES [method]: specifies the coupling method: either de_evb,"
   write(*,*) "    dq_evb, dg_evb or treq can be chosen."
   write(*,*) " * QMDFFNAMES [QMDFF1/2/3]: names of files with QMDFF force fields"
   write(*,*) "    The number of filenames specifies the number of used QMDFFs."
   write(*,*) " * ESHIFT [energies]: Zero point QM energies of all used QMDFFs."
   write(*,*) " * SHIFT_MANUAL: Usually, the QMDFF shift energies are corrected"
   write(*,*) "    slightly to exactly reproduce the first/last energy of the"
   write(*,*) "    energy of the path for a 2EVB. This keyword deactivates it."
   write(*,*) " * ENERGIES_REF [file with MEP-energies (Eh)): All energies"
   write(*,*) "    along a reaction path, for EVB optimization."
   write(*,*) " * COORDS_REF [.xyz file with MEP structures (Angstrom)]:"
   write(*,*) "    structures for energies of the reaction path (see above)"
   write(*,*) " * DE_EVB { \n [COMMANDS] \n}: Specifies the dE-EVB coupling."
   write(*,*) "    - FUNCTION [name of the term]: Used expression for coupling"
   write(*,*) "       function C(dE): one of the following: 1g, 2g, 3g, sd, "
   write(*,*) "       sp, sd2, sp2d, sp2d3.  Default: 1g"
   write(*,*) " * DQ_EVB { \n [COMMANDS] \n}: Specifies the dQ-EVB coupling."
   write(*,*) "    - FUNCTION [name of the term]: Used expression for coupling"
   write(*,*) "       function C(dQ): one of the following: 1g, 3g, sd2 "
   write(*,*) "       Default: 1g"
   write(*,*) " * DG_EVB { \n [COMMANDS \n}: Specifies the DG-EVB coupling." 
   write(*,*) "    - MODE [1/2/3]: Which type of additional reference data"
   write(*,*) "       will be provided for DG-EVB: E, E+G, E+G+H"
   write(*,*) "    - POINTS [N]: Number of DG-EVBN referemce locations."
   write(*,*) "    - DOUBLE_ALPHA: A different exponent will be taken for"
   write(*,*) "       second order functions in the coupling term/optimization"
   write(*,*) "    - READ_COORD: Internal coordinates for the coupling term"
   write(*,*) "       will be read in from file 'coord_def.inp'." 
   write(*,*) "       Else, they will be calculated on the fly."
   write(*,*) "    - POINT_REF [name]: Specifies the file in which gradient"
   write(*,*) "       and frequency information of DG-point is stored. "
   write(*,*)"        Default is 'ref.input'"
   write(*,*) "    - DG_MAT_NUM: (Debugging): calculate the DG-EVB coefficient"
   write(*,*) "       matrix numerically (default: analytically)"
   write(*,*) "    - GAUSS_THRESHOLD [value]: Under which function value a"
   write(*,*) "       DG gaussian will be neglected (default 1E-10)." 
   write(*,*) " * OPT_SETTINGS { \n [COMMAMDS] \n}: Specifies settings for the "
   write(*,*) "    MSLS-LM optimization. If not given, default values are used." 
   write(*,*) "     - START_POINTS [N]: Number of single Levenberg-Marquardt runs"
   write(*,*) "        along the multi start local search for EVB opt. (def: 100)"
   write(*,*) "     - MAXSTEP [N]: Maximum number of Levenberg-Marquardt steps"
   write(*,*) "        per local optimization (default: 100)"
   write(*,*) "     - RANDOM_BONDS [lower] [upper]: borders for randomized finding"
   write(*,*) "        of start values for local opt. (greater than 1!)"
   write(*,*) "     - LM_THRESHOLD [value]: Minimum stepsize for LM step in space"
   write(*,*) "        below that convergence is signaled."
   write(*,*) "     - MORE_INFO: Prints additional output concerning every single"
   write(*,*) "        Levenberg-Marquardt run."
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "------------------------------------------------------------------"
end if
!
!     Program EGRAD: general infos and list of all keywords
!
if (trim(progname) .eq. "egrad") then
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "------ PROGRAM EGRAD.X : SHORT OVERVIEW AND HELP -----------------"
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "--- PART A: basic usage:------------------------------------------"
   write(*,*) "This is the simplest program of the whole package: energies and"
   write(*,*) "gradients are calculated for a given number of structures."
   write(*,*) "The basic usage is: egrad.x qmdff.key"
   write(*,*) "First, the QMDFFs and the EVB coupling must be calculated with"
   write(*,*) "with qmdffgen.x and evbopt.x, all output of these is used here."
!
!     General EVB infos (same for all programs)
!
   call help_evb()
!
!     end of general section for EVB infos
!     start with keywords for EGRAD subprogram
!
   write(*,*) " * COORDS_FILE [.xyz file with structures (Angstrom)]: an"
   write(*,*) "    arbitrary number of structures which energies and gradients"
   write(*,*) "    shall be computed. (usual trajectory format) "
   write(*,*) " * DEBUG: print out single components of QMDFF energies to look"
   write(*,*) "    of it might cause problems.."
   write(*,*) " * PRINT_WILSON [1 or 2]: calculate the Wilson matrix for each "
   write(*,*) "    in the trajectory. The file 'coord_def.inp' defining the "
   write(*,*) "    internal coordinate set must be there as well. If 1 is chosen,"
   write(*,*) "    only the Wilson matrices are written to 'wilson_mat.dat', if "
   write(*,*) "    2 is chosen, the Wilson matrix derivatives are written as well,"
   write(*,*) "    to the file 'wilson_deriv.dat'"
end if
!
!     Program EXPLORE: general infos and list of all keywords
!
if (trim(progname) .eq. "explore") then
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "------ PROGRAM EXPLORE.X : SHORT OVERVIEW AND HELP ---------------"
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "--- PART A: basic usage:------------------------------------------"
   write(*,*) "This program does several basic calculations with the available "
   write(*,*) "PES descriptions, which would be done with usual quantum chemistry"
   write(*,*) "packages: Energy, gradient and hessian/normal mode calculations, "
   write(*,*) "optimizations of minima, transition states and IRC-reaction paths."
   write(*,*) "The basic usage is: explore.x name.key"
   write(*,*) "It originates always at one structure; if you want to want to"
   write(*,*) "calculate energies and gradients at several structures, the"
   write(*,*) "program egrad.x should be prefered."
!
!     General EVB infos (same for all programs)
!
   call help_evb()
!
!     end of general section for EVB infos
!     start with keywords for EVB_QMDFF subprogram
!
   write(*,*) " * XYZSTART [.xyz file with start structure (Angstrom)]: the input"
   write(*,*) "    structure for the calculations."
   write(*,*) " * JOB [name]: Which kind of calculations shall be done:  "
   write(*,*) "    -- OPT_MIN : Optimization towards a minimum "
   write(*,*) "    -- OPT_TS: Optimization towards a TS (+ frequency calc.)"
   write(*,*) "    -- IRC: Optimization of a reaction path (IRC algorithm)"
   write(*,*) "    -- FREQ: Frequencies and normal modes are calculated."
   write(*,*) "    -- OPTFREQ: Minimum optimization + frequency calculation."
   write(*,*) " * OPT { \n [COMMANDS] \n}: Details for MIN/TS optimization."
   write(*,*) "    - MAXITER [number]: maximal number of optimization"
   write(*,*) "       steps. (def.: 500) "
   write(*,*) "    - STEPSIZE [value]: max. length of single step (def.: 0.2)."
   write(*,*) "    - ETHR [value]: energy change convergence criterion"
   write(*,*) "       (def.: 1D-7)"
   write(*,*) "    - GTHR [value]: gradient norm convergence criterion" 
   write(*,*) "       (def.: 1D-7)"
   write(*,*) "    - DTHR [value]: geometry step norm convergence criterion" 
   write(*,*) "       (def.: 1D-7)"
   write(*,*) "    - GMAXTHR [value]: largest component of gradient conv. " 
   write(*,*) "       criterion (def.: 1D-7)"
   write(*,*) "    - DMAXTHR [value]: largest component of geometry step"
   write(*,*) "       convergence criterion (def.: 1D-7)"
   write(*,*) "    - READ_COORD: (TS-opt): read set of manually defined internal"
   write(*,*) "       coordinates from coord_def.inp. Else: automatic."
   write(*,*) " * IRC { \n [COMMANDS] \n}: Details for IRC optimization."
   write(*,*) "    - MAXSTEP: maximum number of IRC steps in each direction."
   write(*,*) "       (def.: 200)"
   write(*,*) "    - STEPLEN: Desired length of an IRC step ((amu)^1/2*bohr)."
   write(*,*) "       (def.: 0.1)"
   write(*,*) "    - EULERLEN: Desired length of elementary Euler step in IRC "
   write(*,*) "       calculations ((amu)^1/2*bohr). It should be much smaller "
   write(*,*) "       than the IRC_STEPLEN! (def.: 0.005)"
   write(*,*) "    - ETHR [value]: IRC energy change convergence criterion"
   write(*,*) "       (def.: 1D-7)"
   write(*,*) "    - GTHR [value]: IRC gradient norm convergence criterion"
   write(*,*) "       (def.: 1D-7)"
   write(*,*) "    - READ_COORD: (TS-opt): read set of manually defined internal"
   write(*,*) "       coordinates from coord_def.inp. Else: automatic."
   write(*,*) "  * FREQ { \n [COMMANDS] \n}: Details for frequency calculation."
   write(*,*) "    - CALC_FRAG: only a part of the molecule will be calculated."
   write(*,*) "       Can be useful to calculate separate educts. A file named "
   write(*,*) "       fragment.inp with indices of atoms needs to be there."
   write(*,*) "    - ORCA_FAKE: An additional name.hess file with the orca "
   write(*,*) "       hessian format will be written (e.g. for subsequent QMDFF" 
   write(*,*) "       generations and benchmarks)."

end if

!
!     Program DYNAMIC: general infos and list of all keywords
!
if (trim(progname) .eq. "dynamic") then
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "------ PROGRAM DYNAMIC.X : SHORT OVERVIEW AND HELP ---------------"
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "--- PART A: basic usage:------------------------------------------"
   write(*,*) "This program runs a single dynamic trajectory under influence of "
   write(*,*) "a thermostate. RPMD can be applied by using several beads."
   write(*,*) "The basic usage is: dynamic.x qmdff.key"
   write(*,*) "You can view the results of the calculation by opening the xyz "
   write(*,*) "file trajectory.xyz, which is always written."
!
!     General EVB infos (same for all programs)
!
   call help_evb()
!
!     end of general section for EVB infos
!     start with keywords for DYNAMIC subprogram
!
   write(*,*) " * XYZSTART [.xyz file with start structure (Angstrom)]: the input"
   write(*,*) "    structure for the calculations."
   write(*,*) " * BEAD_NUMBER [number]: Number of ring polymer beads of the "
   write(*,*) "    system (def.: 1 == classical calculation)"
   write(*,*) " * ENSEMBLE [NVE, NVT or NPT]: Which type of thermodyn. ensemble"
   write(*,*) " * STEPS [number]: Number of single verlet steps in dynamic."
   write(*,*) " * DELTAT [value]: Lengh of a single MD timestep in fs."
   write(*,*) " * TDUMP [value]: Time, after which a new trajectory structure"
   write(*,*) "    shall be written out, in fs."
   write(*,*) " * NVT { \n [COMMANDS] \n}: Specifies the NVT ensemble."
   write(*,*) "    - TEMP [value]: Desired temperature of the system in K." 
   write(*,*) "    - THERMOSTAT [name]: Type of thermostat to be applied (now,"
   write(*,*) "       ANDERSEN, NOSE-HOOVER (chain) are available)."
   write(*,*) "    - PERIODIC [3 values]: Defines the dimensions of the (cubic) "
   write(*,*) "       simulation box given in Angstrom (x, y, z)."
   write(*,*) "    - BOX_WALLS [3 values]: Defines a calculation inside a cubic box"
   write(*,*) "       with reflecting walls, with the box dimensions given in"
   write(*,*) "       Angstrom (x, y, z)." 
   write(*,*) "    - COULOMB [name]: How the Coulomb interactions shall be handeled"
   write(*,*) "       in periodic systems. (PPPME) and ZAHN (cutoff) are available."
   write(*,*) "    - COUL_CUTOFF [value]: Sets the cutoff for Coulomb interactions "
   write(*,*) "       in periodic systems if no Ewald method is used. The default"
   write(*,*) "       is the box length."
   write(*,*) "    - VDW_CUTOFF [value]: Sets the cutoff for dispersion interactions"
   write(*,*) "       in periodic systems. The default value is 10 Angstroms."  
   write(*,*) "    - ANDERSEN_STEP [number]: after how many MD steps the velocity"
   write(*,*) "       reset according to the Andersen thermostat shall be done."
   write(*,*) "       (default: after 7 fs)"
   write(*,*) "    - NOSE_DAMP [number]: The friction factor Q for the Nose-Hoover"
   write(*,*) "       thermostat, in multiples of the MD timestep. (default: 100)" 
   write(*,*) " * NPT { \n [COMMANDS] \n}: Specifies the NPT ensemble."
   write(*,*) "    - TEMP [value]: Desired temperature of the system in K."
   write(*,*) "    - PRES [value]: Desired pressure of the system in atms."
   write(*,*) "    - THERMOSTAT [name]: Type of thermostat to be applied "
   write(*,*) "       (ANDERSEN and NOSE-HOOVER (chain) are available)."
   write(*,*) "    - BAROSTAT [name]: Type of barostat to be applied (BERENDSEN "
   write(*,*) "       and NOSE-HOOVER (chain) are available)."
   write(*,*) "    - PERIODIC [3 values]: Defines the dimensions of the (cubic) "
   write(*,*) "       simulation box given in Angstrom (x, y, z) at the beginning."
   write(*,*) "    - COULOMB [name]: How the Coulomb interactions shall be handeled"
   write(*,*) "       in periodic systems. (PPPME) and ZAHN (cutoff) are available."
   write(*,*) "    - COUL_CUTOFF [value]: Sets the cutoff for Coulomb interactions "
   write(*,*) "       in periodic systems if no Ewald method is used. The default"
   write(*,*) "       is the box length."
   write(*,*) "    - VDW_CUTOFF [value]: Sets the cutoff for dispersion interactions"
   write(*,*) "       in periodic systems. The default value is 10 Angstroms."
   write(*,*) "    - ANDERSEN_STEP [number]: after how many MD steps the velocity"
   write(*,*) "       reset according to the Andersen thermostat shall be done."
   write(*,*) "       (default: after 7 fs)"
   write(*,*) "    - NOSE_DAMP [number]: The friction factor Q for the Nose-Hoover"
   write(*,*) "       thermostat, in multiples of the MD timestep. (default: 100)"
   write(*,*) "    - BARO_DAMP [number]: The damping factor tau for the Nose-Hoover"
   write(*,*) "       barostat, in multiples of the MD timestep. (default: 4000)"
   write(*,*) " * FORCE { \n [COMMANDS] \n}: Activates an applied force simulation."
   write(*,*) "    - VEC1 [number, 4 values]: Atom index on which the first force "
   write(*,*) "       vector shall be applied, and the entries of the vector (a.u.)"
   write(*,*) "    - VEC2 [number, 4 values]: Atom index on which the second force "
   write(*,*) "       vector shall be applied, and the entries of the vector (a.u.)"
   write(*,*) "    - AFM_RUN: activates an atomic force microscope experiment."
   write(*,*) "    - AFM_FIX [number]: Index of the fixed atom at the surface."
   write(*,*) "    - AFM_MOVE [number, 4 values]: Atom index, desired total movement "
   write(*,*) "       and applied displacment vector of the moved atom at AFM tip."
   write(*,*) "    - AFM_AVG [number]: Write frequency of AFM force and lengths"
   write(*,*) "       that will be written to file 'afm_averages.dat'."
   write(*,*) "    - AFM_SECOND [number]: Usually, the program will detect if a "
   write(*,*) "       bond rupture occurs during the AFM simulation. This will "
   write(*,*) "       lead the program look for a second reaction after the given"
   write(*,*) "       number of time steps."
   write(*,*) " * FIX_ATOMS [filename]: Fix a number of atoms during the dynamics."
   write(*,*) "    The specified file contains one atom to be fixed per line."
   write(*,*) " * EVAL_COORD [number]: Values of a list of coordinates during  "
   write(*,*) "    dynamics will be written to file 'coord_eval.dat'. The coords. "
   write(*,*) "    must be defined in 'coord_eval.inp'. One coord per line, one "
   write(*,*) "    number: atom-pos., 2 numbers: distance, 3: angle, 4: dihedral."
   write(*,*) " * SPLIT_ENERGY: The covalent and noncovalent fractions of the "
   write(*,*) "    potential energy will be written to file 'energy_split.dat'"
   write(*,*) " * E_CON: After each step, the current total energy will be "
   write(*,*) "    written out to file energies.dat."
   write(*,*) " * READ_VEL: Read starting velocity from file 'velocity_start.dat."
   write(*,*) "    This file must have the format of 'velocities.dat'"
   write(*,*) " * EWALD_FULL: Benchmarks the Ewald method by comparing the result"
   write(*,*) "    to a brute force Ewald summmation for a single timestep."
   write(*,*) " * OUTPUT_VERBOSE: Print more information than before: gradients to "
   write(*,*) "    'md_gradients.dat', velocities to 'md_velocities.dat' and energies"
   write(*,*) "    to 'md_energies.dat'."
   write(*,*) " * AVG_EKIN: activates the calculation of kinetic energies for a system."
   write(*,*) "    A file named 'list_ekin.dat' with a list of the atoms for which the"
   write(*,*) "    kinetic energy shall be averaged must be present. Else, the "
   write(*,*) "    average is built over all atoms in the system. Further, the "
   write(*,*) "    kinetic energy for each time step is written to 'ekin_step.dat'."
end if

!
!     Program CALC_RATE: general infos and list of all keywords
!
if (trim(progname) .eq. "calc_rate") then
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "------ PROGRAM CALC_RATE.X : SHORT OVERVIEW AND HELP -------------"
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "--- PART A: basic usage:------------------------------------------"
   write(*,*) "This program does all calculations that are needed to determine"
   write(*,*) "the value of a rate constant (k(T)) for a given temperature and"
   write(*,*) "a reaction path. "
   write(*,*) "The basic usage is: calc_rate.x qmdff.key"
   write(*,*) "This calculation can be done in parallel. To invoke this,"
   write(*,*) "type 'mpirun -np [nprocs] [absolute path]/evbopt.x qmdff.key'"
   write(*,*) "The whole rate constant calculation is done in five steps:"
   write(*,*) "A: starting from the TS structure, several structure along the"
   write(*,*) "   path will be optimized to serve as starting points."
   write(*,*) "B: At each umbrella window, the starting structure from A is "
   write(*,*) "   and umbrella equilibrations+samplings are ran. The distri-"
   write(*,*) "   butions of reaction coordinate values (Xi) are stored."
   write(*,*) "C: By taking all Xi distributions, a free energy profile for"
   write(*,*) "  the reaction is generated (by umbrella-integration or WHAM)"
   write(*,*) "D: Starting from the maximum value of the free energy, after a"
   write(*,*) "   equilibration, several recrossing trajectories are started"
   write(*,*) "   to calculate the recrossing factor."
   write(*,*) "E: Free energy barrier as well as recrossing factor are taken"
   write(*,*) "   together in order to calculate the final k(T) value."
   write(*,*) "Usually, steps B and D are the most time-consuming ones (at "
   write(*,*) "least for very accurate calculations). If the calculation is "
   write(*,*) "aborted at some stage, the restart can be initiated from the "
   write(*,*) "end of the last fulfilled step." 
   write(*,*) "Currently, only bimolecular reactions can be calculated, such as"
   write(*,*) "substitutions, additions, cycloadditions and solvent assisted"
   write(*,*) "additions (with 2 to 3 single molecules as second educt)."
!
!     General EVB infos (same for all programs)
!
   call help_evb()
!
!     end of general section for EVB infos
!     start with keywords for RPMD subprogram
!
   write(*,*) " * TS_STRUC [.xyz file with start structure (Angstrom)]: Input"
   write(*,*) "    structure for the calculations, should be the reactions' TS!."
   write(*,*) " * EDUCTS_STRUC [.xyz file]: The reactions educt structure,"
   write(*,*) "    needed for unimolecular reactions (see * below)."
   write(*,*) " * BEAD_NUMBER [number]: Number of ring polymer beads of the "
   write(*,*) "    system (def.: 1 == classical calculation)"
   write(*,*) " * DELTAT [value]: Lengh of a single MD timestep in fs."
   write(*,*) " * NVT { \n [COMMANDS] \n}: Specifies the NVT ensemble."
   write(*,*) "    - TEMP [value]: Desired temperature of the system in K."
   write(*,*) "    - THERMOSTAT [name]: Type of thermostat to be applied (now,"
   write(*,*) "       ANDERSEN, NOSE-HOOVER (chain) are available)."
   write(*,*) "    - ANDERSEN_STEP [number]: after how many MD steps the velocity"
   write(*,*) "       reset according to the Andersen thermostat shall be done."
   write(*,*) "       (Default: after 7 fs)"
   write(*,*) "    - NOSE_DAMP [number]: The friction factor Q for the Nose-Hoover"
   write(*,*) "       thermostat, in multiples of the MD timestep. (Default: 100)"
   write(*,*) " * MECHA { \n [COMMANDS] \n}: Specifices the reaction mechanism."
   write(*,*) "    - TYPE [type]: Which predefined class of elementary reactions"
   write(*,*) "       shall be calculated. Possible options are (*: unimolecular):"
   write(*,*) "       -- BIMOLEC: A bimolecular substitution."
   write(*,*) "       -- ATOM_SHIFT *: A single atom is transported a certain "
   write(*,*) "          distance, e.g. on a metal surface."
   write(*,*) "       -- MERGING: Two fragments merge, one bond is formed."
   write(*,*) "       -- ELIMINATION *: A classical elimination reaction."
   write(*,*) "       -- REARRANGE *: A rearrangement within one molecule."
   write(*,*) "       -- DECOM_1BOND *: A molecule decomposes, one bond broken."
   write(*,*) "       -- CYCLOADD: An usual cycloadditon (forward direction)"
   write(*,*) "       -- CYCLOREV *: A cycloreversion (two bonds broken at once)."
   write(*,*) "       -- ADDITION: Two molecules merge to one product."    
   write(*,*) "       -- ADDITION3: Three molecules merge to two products."
   write(*,*) "       -- ADDITION4: Four molecules merge to three products."
   write(*,*) "       -- ADD3_SOLV: One single and two pre-clustered reactants."
   write(*,*) "       -- ADD4_SOLV: One single and three pre-clustered reactants."
   write(*,*) "    - EDUCT[1,2,3,4] [list of numbers]: Depending on the type of "
   write(*,*) "       reaction, for each educt its atoms need to be specified"
   write(*,*) "       on a distinct line (e.g., EDUCT1 5 7 8 9)."   
   write(*,*) "    - R_INF [value]: Distance between the reactants at Xi=0 where"
   write(*,*) "       no interactions are noticed, in Ang. (recommended: 8-15)."
   write(*,*) "    - BOND_FORM [list]: List of bonds that are going to be formed"
   write(*,*) "       during the reaction (example: 1-2 4-5)"
   write(*,*) "    - BOND_BREAK [list]: List of broken bonds, see above."
   write(*,*) "    - N_PATHS [number]: Number of equivalent reaction paths for "  
   write(*,*) "       the given combination of reactants (e.g., H+H2: 2)."
   write(*,*) "    - SHIFT_ATOM [index]: Which atom shall be shifted, only for "
   write(*,*) "       ATOM_SHIFT type!" 
   write(*,*) "    - SHIFT_COORD [X, Y or Z]: Which direction the atom shall be"
   write(*,*) "       shifted, only for ATOM_SHIFT type!"
   write(*,*) "    - SHIFT_INTERV [low, high]: Coordinate interval (Angstrom),"
   write(*,*) "       along the atom shall be shifted, only ATOM_SHIFT type!"
   write(*,*) " * UMBRELLA: { \n [COMMANDS] \n}: Speficies the calculations in "
   write(*,*) "       umbrella sampling phase, where the reaction is sampled."
   write(*,*) "    - BIAS [value]: Strength of the umbrella force constant"
   write(*,*) "       in a.u."
   write(*,*) "    - BONDS [value1] [value2]: Range of coordinate Xi, in"
   write(*,*) "       which umbrella samplings shall be done. The min. range is"
   write(*,*) "       0 (educts) to 1 (TS), however, it is strongly recommended"
   write(*,*) "       to expand this range by at least 0.05 in both directions."
   write(*,*) "    - DIST [value]: Step in coordinate Xi between two "
   write(*,*) "       umbrella sampling positions (recommended: 0.01)."
   write(*,*) "    - GEN_STEPS [number]: Number of MD steps per trajectory"
   write(*,*) "       for generation of umbrella starting structures."
   write(*,*) "    - EQUI_STEPS [number]: Number of MD steps for a single "
   write(*,*) "       umbrella equilibration trajectory (preliminary for each"
   write(*,*) "       real sampling trajectory."
   write(*,*) "    - SAMPLE_STEPS [number]: Number of MD steps for a single"
   write(*,*) "       umbrella sampling trajectory, for generation of PMF data"
   write(*,*) "    - SAMPLE_TRAJS [number]: Number of umbrella trajectores (each"
   write(*,*) "       with an eqilibration for its own) per umbrella window." 
   write(*,*) " * PMF: { \n [COMMANDS] \n}: Calculation of the potential of mean"
   write(*,*) "       force (PMF) surface from umbrella sampling results."
   write(*,*) "    - XI_RANGE [value1} [value2]: Interval of Xi, in which the "
   write(*,*) "       free energy of the calculation will be calculated. (Should"
   write(*,*) "       be slightly smaller than the umbrella_bonds interval.)"
   write(*,*) "    - BINS [number]: Number of points along the interval, where "
   write(*,*) "       the free energy is calculated (Should be 1000 or more)."
   write(*,*) "    - METHOD [method]: Used method for PMF surface calculation."
   write(*,*) "       Options are INTEGRATION, WHAM or ALL." 
   write(*,*) "    - MINLOC: [ZERO/PMF_MIN]: method for chosing the lower PMF"
   write(*,*) "       value in the k(T) formula. Asymtotic or the lowest PMF."
   write(*,*) " * RECROSS: { \n [COMMANDS] \n}: Calculation of the recrossing "
   write(*,*) "       factor for the final rate constant."
   write(*,*) "    - EQUI_STEPS [number]: Number of MD steps for equilibration"
   write(*,*) "       trajectory at beginning of recrossing part."
   write(*,*) "    - CHILD_TOTAL [number]: Total number of single child trajs."
   write(*,*) "       that are started to estimate recrossing. Should be more "
   write(*,*) "       than 5000 to 10000 individuals."
   write(*,*) "    - CHILD_INTERVAL [number]: How many MD steps are simulated"
   write(*,*) "       between two positions of child spawning (in order to get a"
   write(*,*) "       larger pool of starting conditions.)"
   write(*,*) "    - CHILD_PERPOINT [number]: How many childs are spawned per "
   write(*,*) "       position between intervals (recommended: 100) "
   write(*,*) "    - CHILD_STEPS [number]: How many MD steps a child trajectory"
   write(*,*) "       is simulated. Can be quite short! (50-100 fs)"
   write(*,*) "    - MPI: If the recrossing part shall be parallelized with MPI"
   write(*,*) "       as well. Faster but might be unstable so far!"
   write(*,*) "    - NO_CHECK: Deactivates control for bead behavior only for "
   write(*,*) "       recrossing trajectories."
   write(*,*) " * FORCE: { \n [COMMANDS] \n}: Activates an applied force during "
   write(*,*) "       the whole rate constant calculation."
   write(*,*) "    - VEC1 [number, 4 values]: Atom index on which the first "
   write(*,*) "       force vector shall be applied, the magnitude of the force "
   write(*,*) "       and the entries of the vector (a.u.)"
   write(*,*) "    - VEC2 [number, 4 values]: Atom index on which the second "
   write(*,*) "       force vector shall be applied, the magnitude of the force " 
   write(*,*) "       and the entries of the vector (a.u.)"
   write(*,*) " * PRINT_POLYMER [Xi value]: If for exemplification one umbrella"
   write(*,*) "    trajectory shall be printed. First for the given Xi value."
   write(*,*) " * FIX_ATOMS [filename]: Fix a number of atoms during the dynamics."
   write(*,*) "    The specified file should include all atoms to be fixed."
   write(*,*) " * TDUMP [value]: Time, after which a new trajectory structure"
   write(*,*) "    shall be written out, in fs (only for PRINT_POLYMER)."
   write(*,*) " * GEN_TEST: Only the structure generation part will be calculated"
   write(*,*) "    and structures and energies will be printed out."
   write(*,*) " * MAX_ERROR [number]: maximum number or errors that might occur"
   write(*,*) "    in a rpmd.x calculation before program termination."
   write(*,*) " * NO_CHECK: Deactivate control after each dynamic step for bad"
   write(*,*) "    behavior. Should only used in special cases!"
   write(*,*) " * DEBUG: All structures of part A (equilibration) are written to"
   write(*,*) "    file debug_traj.xyz. Very large files! Only recrommended for"
   write(*,*) "    severe problems with current reaction."
end if

!
!     Program EVB_KT_DRIVER: general infos and list of all keywords
!


if (trim(progname) .eq. "evb_kt_driver") then
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "---- PROGRAM EVB_KT_DRIVER.X : SHORT OVERVIEW AND HELP -----------"
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "--- PART A: basic usage:------------------------------------------"
   write(*,*) "This program is aimed to be a black box interface for calculating"
   write(*,*) "reaction rate constants if only an IRC is given."
   write(*,*) "In order to do that, QMDFF reference calculation as well as force"
   write(*,*) "field generation and EVB parametrization is automated here. In"
   write(*,*) "order to avoid nasty EVB and ambiguous optimization, RP-EVB is "
   write(*,*) "used here automatically. Currently, only Gaussian IRCs can be used"
   write(*,*) "as path reference. Only Gaussian can be used for minizations and "
   write(*,*) "RP-EVB point calculations. To get even better performances, "
   write(*,*) "energies of the IRC structures might be recalculated at a better "
   write(*,*) "level of theory. This can only be done with orca. "
   write(*,*) "To groups of keywords can be given: Mandantory general keywords and"
   write(*,*) "keywords for the rpmd.x k(T) calculations. These are mostly like"
   write(*,*) "the usual rpmd.x keywords listed at 'rpmd.x -h'."
   write(*,*) "--- PART B: List of general keywords:----------------------"
   write(*,*) "These keywords can be written into the qmdff.key input file:"
   write(*,*) " * SOFTWARE [G]: Used software for IRC calculation. Currently,"
   write(*,*) "    only Gaussian can be used."
   write(*,*) " * IRC_PREFIX [file prefix]: Prefix for needed IRC input files."
   write(*,*) "    The files prefix.log and prefix.chk needs to be present."
   write(*,*) " * IRC_DIRECTION [right2left / left2right]: Direction if the "
   write(*,*) "    desired reaction with respect to the given IRC."
   write(*,*) " * GF_METHOD [words]: Used QM reference method for references."
   write(*,*) " * GF_BASIS [words]: Used basis sets for QM method for references."
   write(*,*) "    other needed settings could also be stated here,"
   write(*,*) " * NPROCS_TOTAL [number]: Number of processors that are availiable"
   write(*,*) "    for the full calculation. For a large number, several tasks" 
   write(*,*) "    can be done in parallel. default: 2"
   write(*,*) " * MIN_RP_POINTS [number]: The total number N of RP-EVB reference "
   write(*,*) "    points will be calculated as: N=min+n_at/2, where n_at is the"
   write(*,*) "    number of atoms in the system. This keywords reads in 'min'."
   write(*,*) " * RPMD_TEMPS [number list]: All temperatures, for them k(T) "
   write(*,*) "    shall be calculated. For two or more, Arrhenius parameters "
   write(*,*) "    will also be calculated."
   write(*,*) " * MANUAL_INT [filename]: The rpmd.x calculations will be done with"
   write(*,*) "    with a predefined internal coordinate set to be read in from"
   write(*,*) "    the given file."
   write(*,*) " * MIN_PROCS [number]: Number of processors to be used for the "
   write(*,*) "    optimization of QMDFF minima. The max. number is NPROCS_TOTAL."
   write(*,*) "    default: 1"
   write(*,*) " * RP_REF_NPROCS [number]: Number of processors to be used for the"
   write(*,*) "    calculation of RP-EVB reference points (gradients+frequencies)."
   write(*,*) "    default: 1:"
   write(*,*) " * REF_MEMORY [number]: Size of memory (GB) for each reference"
   write(*,*) "    calculation. default: 4"
   write(*,*) " * LINK_GAUSSIAN [path]: Absolute path of the Gaussian executable."
   write(*,*) " * LINK_ORCA [path]: Absolute path of the orca executable."
   write(*,*) " * LINK_QMDFFGEN [path]: Absolute path of the qmdffgen.x executable."
   write(*,*) " * LINK_RPMD [path]: Absolute path of the rpmd.x exetubale."
   write(*,*) "--- PART C: List of RPMD (T) calculation keywords:-----------------"
   write(*,*) " * DELTAT [value]: Lengh of a single MD timestep in fs."
   write(*,*) " * THERMOSTAT [name]: Type of thermostat to be applied (now,"
   write(*,*) "    only the Andersen thermostat can be chosen)."
   write(*,*) " * BEAD_NUMBER [number]: Number of ring polymer beads of the "
   write(*,*) "    system (def.: 1 == classical calculation)"
   write(*,*) " * DIST_MATRIX: Internal coordinates will be simply a distance"
   write(*,*) "    matrix of all atoms in the system! This should only be done"
   write(*,*) "    if all other methods fail, because it scales with N^2!"
   write(*,*) " * PATH_DIST_LIMIT [value]: maximum z value above which either "
   write(*,*) "    QMDFF1 or 2 will be used as references (because the s-value"
   write(*,*) "    will be considered as failed). Useful, if calculations cancel"
   write(*,*) "    with enormous high energies at arbitrary points."
   write(*,*) " * GENERATE_STEPS [number]: Number of MD steps per trajectory"
   write(*,*) "    for generation of umbrella starting structures."
   write(*,*) " * EQUILIBR_STEPS [number]: Number of MD steps for a single "
   write(*,*) "    umbrella equilibration trajectory (preliminary for each"
   write(*,*) "    real sampling trajectory."
   write(*,*) " * UMBRELLA_STEPS [number]: Number of MD steps for a single"
   write(*,*) "    umbrella sampling trajectory, which Xi data are postprocessed."
   write(*,*) " * UMBRELLA_TRAJS [number]: Number of umbrella trajectores (each"
   write(*,*) "    with an eqilibration for its own) per umbrella window."
   write(*,*) " * UMBRELLA_BIAS [value]: Strength of the umbrella force constant"
   write(*,*) "    in a.u."
   write(*,*) " * UMBRELLA_BONDS [value1] [value2]: Range of coordinate Xi, in"
   write(*,*) "    which umbrella samplings shall be done. The minimal range is"
   write(*,*) "    0 (educts) to 1 (TS), however, it is strongly recommended"
   write(*,*) "    to expand this range by at least 0.05 in both directions."
   write(*,*) " * UMBRELLA_DIST [value]: Step in coordinate Xi between two "
   write(*,*) "    umbrella sampling positions (recommended: 0.01)."
   write(*,*) "    no interactions are noticed, in bohr (recommended: 15-30)."
   write(*,*) " * PRESAMPLE: For ADDITION3/4, do a previous calculation in order"
   write(*,*) "    to ensure that all educts are separated with equal distance."
   write(*,*) " * PMF_XI_RANGE [value1] [value2]: Interval of Xi, in which the "
   write(*,*) "    free energy of the calculation will be calculated. It should"
   write(*,*) "    be slightly smaller than the umbrella_bonds interval."
   write(*,*) " * PMF_BINS [number]: Number of points along the interval, on "
   write(*,*) "    the free energy is calculated (should be 1000 or more)."
   write(*,*) " * PMF_METHOD [method]: Used method for free energy (==PMF) calc."
   write(*,*) "    Options are INTEGRATION, WHAM or ALL."
   write(*,*) " * RECROSS_EQUI [number]: Number of timesteps for equilibration"
   write(*,*) "    trajectory at beginning of recrossing part."
   write(*,*) " * CHILD_TOTAL [number]: Total number of single child trajectories"
   write(*,*) "    that are started to estimate recrossing. Should be more than"
   write(*,*) "    1000 or 10000 individuals."
   write(*,*) " * CHILD_INTERVAL [number]: How many timesteps are simulated"
   write(*,*) "    in between two positions of child spawning (in order to get a"
   write(*,*) "    larger pool of starting conditions."
   write(*,*) " * CHILD_PERPOINT [number]: How many childs are spawned per point"
   write(*,*) "    between intervals (recommended: 100) "
   write(*,*) " * CHILD_EVOL [number]: How many timesteps a child trajectory"
   write(*,*) "    is simulated. Can be quite short! (50-100 fs)"
   write(*,*) " * RECROSS_MPI: If the recrossing part shall be parallelized with"
   write(*,*) "    MPI. It is faster but breaks at certain systems."
   write(*,*) " * PRINT_POLYMER [Xi value]: If for exemplification one umbrella"
   write(*,*) "    shall be written out, the first for the given Xi value."
   write(*,*) " * TDUMP [value]: Time, after which a new trajectory structure"
   write(*,*) "    shall be written out, in fs (only for PRINT_POLYMER)."
   write(*,*) " * DEBUG: All structures of part A (equilibration) are written to"
   write(*,*) "    file debug_traj.xyz. Very large files! Only recrommended for"
   write(*,*) "    severe problems with current reaction."
   write(*,*) " * NO_CHECK: Deactivate control after each dynamic step for bad"
   write(*,*) "    behavior. Should only used in special cases!"
end if

if (trim(progname) .eq. "mult_qmdff") then
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "------ PROGRAM MULT_QMDFF.X : SHORT OVERVIEW AND HELP ------------"
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "--- PART A: basic usage:------------------------------------------"
   write(*,*) "This program automatically builds up a solvent box of up to 8000"
   write(*,*) "molecules of up to 10 different species."
   write(*,*) "Before invoking this program, you should generate QMDFFs for all"
   write(*,*) "different single solvent molecules that shall be present in the"
   write(*,*) "final box. These can be generated with qmdffgen.x"
   write(*,*) "When the QMDFFs are present, mult_qmdff.x can be started and the"
   write(*,*) "different specifications of the box are read in via an interactive"
   write(*,*) "process. When everything is finished, two files are generated:"
   write(*,*) "'box.xyz', containing the xyz-coordinates of the box (for checkup"
   write(*,*) "and start structure) and 'box.qmdff', containing the QMDFF of the"
   write(*,*) "whole box system!"
   write(*,*) "With this single QMDFF, the whole box is represented and "
   write(*,*) "calculations with egrad.x or dynamic.x can be invoked as it is "
   write(*,*) "done for a usual single-molecule QMDFF."
   write(*,*) "Note that the formate of the 'box.qmdff' is sligtly different "
   write(*,*) "than that of usual QMDFFs. In order to avoid a giant blow up of"
   write(*,*) "noncovalent interaction assignments (which scale with N^2), only"
   write(*,*) "intramolecular noncovalent interactions are noted in the file,"
   write(*,*) "as they are noted in the reference QMDFFs of the single molecules."
   write(*,*) "All intermolecular interactions are then calculated on the fly."
   write(*,*) "This is made possible by adding the number of the molecule to"
   write(*,*) "to which the current atom belongs at the last column of the "
   write(*,*) "coordinate section. In the original QMDFFs, there is a not-used"  
   write(*,*) "zero in this column, such that the general format is retained."
   write(*,*) "In addition, the total number of molecules is written in the first"
   write(*,*) "line of the file as second parameter (again replacing a dummy"
   write(*,*) "variable)."
   write(*,*) "Usually, one wants to run periodic calculations with the generated"
   write(*,*) "'box.qmdff' file. The needed box dimensions are written out by"
   write(*,*) "mult_qmdff.x as well, adding a safety vacuum layer of one Angstrom"
   write(*,*) "around the molecule bulk."
   write(*,*) "If desired, the user can add optimized noncovalent parameters as"
   write(*,*) "obtained from qmdffopt.x. The file [QMDFF-prefix]_mod.dat must"
   write(*,*) "be present in this case."
end if

if (trim(progname) .eq. "qmdffopt") then
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "------ PROGRAM QMDFFOPT.X : SHORT OVERVIEW AND HELP --------------"
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "--- PART A: basic usage:------------------------------------------"
   write(*,*) "This program introduces additional modification parameters "
   write(*,*) " in order to optimize the nonbonded interaction terms of a "
   write(*,*) " given QMDFF for an even better description of noncovalent"
   write(*,*) " interactions (e.g. for liquid simulations)"
   write(*,*) "The program execution consists of two steps:"
   write(*,*) " - First, structures for QM reference calculations will be "
   write(*,*) "   generated. For this, the program call should be "
   write(*,*) "   'qmdffopt.x -prepare'. The structure of the given QMDFF is taken "
   write(*,*) "   and dimers are generated ny chance, by means of spherical "
   write(*,*) "   coordinates (for the COMs) and Euler angles (for the rotation"
   write(*,*) "   of the second molecule in relation to the first."
   write(*,*) "   The obtained structures are written to 'trajectory.xyz'"
   write(*,*) "   and 'trajectory_orca.xyz' and should be used as input "
   write(*,*) "   structures for subsequent QM calculations with a program "
   write(*,*) "   of choice. The handling is fully interactive."
   write(*,*) " - Second, the calculated energies of the QM method are "
   write(*,*) "   taken as input for the QMDFF correction parameter optimization."
   write(*,*) "   The program call should be 'qmdffopt.x -optimize [keyfile]'"
   write(*,*) "   Then, a Multi-Start-Local-Search Levenberg-Marquardt "  
   write(*,*) "   optimization of the parameters is done. "
   write(*,*) "   The resulting correction factors are written to the file "
   write(*,*) "   '[QMDFF-prefix]_mod.dat."
   write(*,*) "------------------------------------------------------------------"
   write(*,*) "--- PART B: List of all availiable keywords:----------------------"
   write(*,*) "This keywords can be written into the qmdff.key input file:"
   write(*,*) " * FFNAME [QMDFF]: Name of QMDFF force field file"
   write(*,*) " * 1QMDFF [energy]: Energy shift of the given QMDFF file"
   write(*,*) " * REF_ENERGIES [file with trainset-energies (Eh)): The calculated."
   write(*,*) "    QM-energies of the trainset. If absent, the file "
   write(*,*) "    'trainset_ens.dat' will be looked for."
   write(*,*) " * REF_STRUCTURE [.xyz file with trainset structures (Angstrom)]:"
   write(*,*) "    structures of the trainset. If absent. the file 'trainset.xyz'"
   write(*,*) "    will be looked for."
   write(*,*) " * START_POINTS [N]: Number of single Levenberg-Marquardt starts"
   write(*,*) "    along the multi start local search for opt. (def: 100)"
   write(*,*) " * MAXSTEP [N]: Maximum number of Levenberg-Marquardt steps per"
   write(*,*) "    local optimization (default: 100)"
   write(*,*) " * RANDOM_BONDS [lower] [upper]: borders for randomized finding"
   write(*,*) "    of start values for local opt. (default would be 1.0!)"
   write(*,*) " * LM_THRESHOLD [value]: Minimum stepsize for Levenberg-Marquardt"
   write(*,*) "    below that convergence is signaled."
   write(*,*) " * MORE_INFO: Prints additional output concerning every single"
   write(*,*) "    Levenberg-Marquardt run."


end if

write(*,*) "------------------------------------------------------------------"
return
end subroutine help

!
!     subroutine help_evb: printing all keywors for general EVB-QMDFF
!        usage. This routine will be called by all programs that uses 
!        parametrized EVB-QMDFFs
! 
!     part of EVB
!
       
subroutine help_evb()
implicit none

!
!     General EVB infos (same for all programs)
!
write(*,*) "------------------------------------------------------------------"
write(*,*) "--- PART B: List of general EVB-QMDFF keywords:-------------------"
write(*,*) " * FFNAME [QMDFF1/2/3]: names of files with QMDFF force fields"
write(*,*) " * PES [method]: specifies the coupling method: Available are:"
write(*,*) "    - QMDFF  (a single QMDFF for the whole PES)"
write(*,*) "    - DE_EVB (energy-dependent coupling)"
write(*,*) "    - DQ_EVB (coordinate-dependent coupling)"
write(*,*) "    - DG_EVB (distributed Gaussian EVB)"
write(*,*) "    - TREQ (transition region corrected reaction path EVB)"
write(*,*) "    - ORCA (direct gradient call to the orca QM package)"
write(*,*) "    - WATER_SPC (the flexible simple point charge water model)"
write(*,*) "    - ANA_H3, ANA_BRH2, ANA_O3, ANA_OH3, ANA_CLNH3, ANA_CH4H, "
write(*,*) "       ANA_NH3OH, ANA_CH4OH, ANA_CH4CN, ANA_GEH4OH, ANA_C2H7 "
write(*,*) "       (analytical PES functions from the literature)"
write(*,*) "    (NOTE: for DE_EVB, DQ_EVB and DG_EVB, the file 'evb_pars.dat'"
write(*,*) "     containing the EVB coupling parameters must be there!)"
write(*,*) " * QMDFFNAMES [QMDFF1/2/3]: names of files with QMDFF force fields"
write(*,*) "    The number of filenames specifies the number of used QMDFFs."
write(*,*) " * ESHIFT [energies]: Zero point QM energies of all used QMDFFs."
write(*,*) " * SHIFT_MANUAL: Usually, the QMDFF shift energies are corrected"
write(*,*) "    slightly to exactly reproduce the first/last energy of the"
write(*,*) "    energy of the path for a 2EVB. This keyword deactivates it."
write(*,*) " * ENERGIES_REF [file with MEP-energies (Eh)): All energies"
write(*,*) "    along a reaction path, for EVB optimization."
write(*,*) " * COORDS_REF [.xyz file with MEP structures (Angstrom)]:"
write(*,*) "    structures for energies of the reaction path (see above)"
write(*,*) " * DE_EVB { \n [COMMANDS] \n}: Specifies the dE-EVB coupling."
write(*,*) "    - FUNCTION [name of the term]: Used expression for coupling"
write(*,*) "       function C(dE): one of the following: 1g, 2g, 3g, sd, "
write(*,*) "       sp, sd2, sp2d, sp2d3.  Default: 1g"
write(*,*) " * DQ_EVB { \n [COMMANDS] \n}: Specifies the dQ-EVB coupling."
write(*,*) "    - FUNCTION [name of the term]: Used expression for coupling"
write(*,*) "       function C(dQ): one of the following: 1g, 3g, sd2 "
write(*,*) "       Default: 1g"
write(*,*) " * DG_EVB { \n [COMMANDS \n}: Specifies the DG-EVB coupling."
write(*,*) "    - MODE [1/2/3]: Which type of additional reference data"
write(*,*) "       will be provided for DG-EVB: E, E+G, E+G+H"
write(*,*) "    - POINTS [N]: Number of DG-EVB referemce locations."
write(*,*) "    - DOUBLE_ALPHA: A different exponent will be taken for"
write(*,*) "       second order functions in the coupling term/optimization"
write(*,*) "    - READ_COORD: Internal coordinates for the coupling term"
write(*,*) "       will be read in from file 'coord_def.inp'."
write(*,*) "       Else, they will be calculated on the fly. Formate is:"
write(*,*) "         -- Two atom numbers: bond length"
write(*,*) "         -- Three atom numbers: bond angle"
write(*,*) "         -- 0 + Four atom numbers: torsion angle"
write(*,*) "         -- 1 + Four atom numbers: out of plane coordinate"
write(*,*) "    - POINT_REF [name]: Specifies the file in which gradient"
write(*,*) "       and frequency information of DG-point is stored. "
write(*,*)"        Default is 'ref.input'"
write(*,*) "    - DG_MAT_NUM: (Debugging): calculate the DG-EVB coefficient"
write(*,*) "       matrix numerically (default: analytically)"
write(*,*) "    - GAUSS_THRESHOLD [value]: Under which function value a"
write(*,*) "       DG gaussian will be neglected (default 1E-10)."
write(*,*) " * TREQ { \n [COMMANDS \n}: Specifies the TREQ description."
write(*,*) "    - POINTS [N]: Number of gradient/Hessian referemce locations."
write(*,*) "    - IRC_STRUC [.xyz file with pathstructures (Angstrom)]: "
write(*,*) "       reaction path structures to be interpolated."
write(*,*) "    - IRC_ENS [file with path energies (Eh)]: energies for the"
write(*,*) "       structures of reaction path"
write(*,*) "    - READ_COORD: Internal coordinates for the interpolations"
write(*,*) "       will be read in from file 'coord_def.inp'."
write(*,*) "       Else, they will be calculated on the fly. Formate is:"
write(*,*) "         -- Two atom numbers: bond length"
write(*,*) "         -- Three atom numbers: bond angle"
write(*,*) "         -- 0 + Four atom numbers: torsion angle"
write(*,*) "         -- 1 + Four atom numbers: out of plane coordinate"
write(*,*) "    - RP_EXP_COEFF [value]: Coefficient of the gaussian function"
write(*,*) "       that damps the coupling in regions orthogonal to path."
write(*,*) "    - RP_EVB_MID [2 values]: Width of the direct interpilation "
write(*,*) "       interval along the reaction path (in units of s), first"
write(*,*) "       value: with of direct interpolation, second value: width"
write(*,*) "       of transition region to RP-EVB description."
write(*,*) "    - PAR_ETA [value]: measure for switch-off interval for"
write(*,*) "       coupling: the larger, the smaller is the interval."
write(*,*) "    - S_BORDERS_MAN [s_Q1_R,s_R_RI,s_RI_I,s_I_RI,s_RI_R]: Give "
write(*,*) "       the borders of the different sections along the path "
write(*,*)"        manually and without symmetry in terms of s-values."
write(*,*) "    - INTERP_TOL [value]: minimum size of interval for numerical"
write(*,*) "       projection of point to MEP (RP-EVB)"
write(*,*) "    - RP_ANA_STEP [value]: for analytical RP_EVB gradient: the"
write(*,*) "       part along the reaction path needs to be calculated "
write(*,*) "       numerically."
write(*,*) "    - DIST_MATRIX: Internal coordinates will be simply a distance"
write(*,*) "       matrix of all atoms in the system! This should only "
write(*,*) "       done if all methods fail, because it scales with N^2!"
write(*,*) "    - PATH_DIST_LIMIT [value]: maximum z value above which either "
write(*,*) "       QMDFF1 or 2 will be used as references (because the s-value"
write(*,*) "       will be considered as failed). Useful, if calculations"
write(*,*) "       cancel with enormous high energies at arbitrary points."
write(*,*) "    - IRC_LOCAL [number]: For RP-EVB, acceleration of calculation "
write(*,*) "       by local testing of IRC per step. How many structures "
write(*,*) "       left/right on the IRC shall be tested? (default: 5)"
write(*,*) " * INT_GRAD_PLOT: Plot internal gradients for all"
write(*,*) "    structures during a calculation (DG-EVB/TREQ)."
write(*,*) " * INT_COORD_PLOT: Plot internal coordinates for all structures"
write(*,*) "    during a calculation (DG-EVB/TREQ)."
write(*,*) " * NUM_GRAD: gradients are calculated numerically. (mainly debug)."
write(*,*) " * NUM_GRAD_STEP [value]: Elongation step size for numerical"
write(*,*) "    gradients."
write(*,*) " * GEN_TEST [number]: do only structure generation part and write"
write(*,*) "    every [number] structure occuring during calculation."
write(*,*) "------------------------------------------------------------------"
write(*,*) "--- PART C: List of program specific keywords:--------------------"


return
end subroutine help_evb
